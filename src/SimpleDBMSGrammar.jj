/**
 * @file    SimpleDBMSGramar.jj
 * @author  2014-18992 신동진
 * @brief   Basic SQL grammar parser
 */
options {
  static = true;
  DEBUG_PARSER = false;
  IGNORE_CASE = true;
}

PARSER_BEGIN(SimpleDBMSParser)

import marodb.MaroDBMS;
import marodb.Field;
import marodb.type.DataType;
import marodb.type.IntType;
import marodb.type.CharType;
import marodb.type.DateType;
import marodb.constraint.Constraint;
import marodb.constraint.PkConstraint;
import marodb.constraint.FkConstraint;
import marodb.util.Pair;
import marodb.exceptions.QueryError;
import marodb.exceptions.SchemaError;
import java.util.ArrayList;

public class SimpleDBMSParser {
  /// Type of SQL queries
  public static final int PRINT_SYNTAX_ERROR = 0;
  public static final int PRINT_CREATE_TABLE = 1;
  public static final int PRINT_DROP_TABLE =   2;
  public static final int PRINT_DESC =         3;
  public static final int PRINT_SELECT =       4;
  public static final int PRINT_INSERT =       5;
  public static final int PRINT_DELETE =       6;
  public static final int PRINT_SHOW_TABLES =  7;
  public static MaroDBMS dbms;

  public static void main(String args[]) throws ParseException {
    SimpleDBMSParser parser = new SimpleDBMSParser(System.in);
    System.out.print("DB_2014-18992> ");
    dbms = new MaroDBMS();

    while (true) {
      try {
        parser.command();
      }
      catch (Throwable e) {
        System.out.println(e.getMessage());
        printMessage(PRINT_SYNTAX_ERROR);
        SimpleDBMSParser.ReInit(System.in);
      }
    }
  }

  public static void printMessage(int q) {
    switch(q) {
      case PRINT_SYNTAX_ERROR:
      	System.out.println("Syntax error");
      	break;
      case PRINT_CREATE_TABLE:
      	break;
      case PRINT_DROP_TABLE:
      	break;
      case PRINT_DESC:
      	break;
      case PRINT_INSERT:
      	break;
      case PRINT_DELETE:
      	break;
      case PRINT_SELECT:
      	break;
      case PRINT_SHOW_TABLES:
      	break;
    }
    System.out.print("DB_2014-18992> ");
  }
}

PARSER_END(SimpleDBMSParser)

SKIP : { " " | "\r" | "\t" | "\n" }

TOKEN : /* Keywords */ {
  < EXIT : "exit" >
| < INT : "int" >
| < CHAR : "char" >
| < DATE : "date" >
| < REFERENCES : "references" >
| < DESC : "desc" >
| < SELECT : "select" >
| < AS : "as" >
| < FROM : "from" >
| < WHERE : "where" >
| < OR : "or" >
| < AND : "and" >
| < NOT : "not" >
| < IS : "is" >
| < VALUES : "values" >
| < NULL : "null" >
| < TABLES : "tables">
| < TABLE : "table">
| < KEY : "key" >
| < INSERT : "insert" >
| < INTO : "into" >
| < DELETE : "delete" >
| < DROP : "drop">
| < SHOW : "show">
| < PRIMARY : "primary">
| < CREATE : "create">
| < FOREIGN : "foreign">
}

/// Tokens that are not reserved keywords
TOKEN : {
  < SEMICOLON : ";" >
| < LEFT_PAREN : "(" >
| < RIGHT_PAREN : ")" >
| < COMMA : "," >
| < #UNDERSCORE : "_" >
| < #SIGN : "+" | "-" >
| < DATE_VALUE : <NNNN> "-" <NN> "-" <NN> >
| < #DIGIT : [ "0"-"9" ] >
| < #ALPHABET : [ "A"-"Z", "a"-"z" ] >
| < #QUOTE : "'">
| < PERIOD : ".">
| < ASTERISK : "*">
| < #NNNN : (<DIGIT>){4} >
| < #NN : (<DIGIT>){2} >
| < LEQ : "<=">
| < LT : "<">
| < GEQ : ">=">
| < GT : ">">
| < EQ : "=">
| < NEQ : "!=">
| < CHARSTRING : <QUOTE> (<NON_QUOTE_SPECIAL_CHARACTER> | <DIGIT> | <ALPHABET> | " ")* <QUOTE> >
| < #NON_QUOTE_SPECIAL_CHARACTER : ["~", "`", "!", "@", "#", "$", "%", "^", "&",
"*", "(", ")", "-", "_", "+", "=", "|", "{", "[", "]", "}", "\\", ";", ":", ",",
"<", ".", ">", "?", "/"]>
| < LEGAL_IDENTIFIER : <ALPHABET> ( <ALPHABET> | <UNDERSCORE> )* >
| < INT_VALUE : ( <SIGN> )? ( <DIGIT> )+ >
}

void command() : {} {
  queryList()
| ( <EXIT> <SEMICOLON> { dbms.close(); System.exit(0); } )
}

void queryList() : { int q; } {
  (
    q = query()
    <SEMICOLON>
    { printMessage(q); }
  )+
}

/// @brief  Parse query and return its type
/// @param  int q Result query code
int query() : { int q; } {
  (
    createTableQuery() { q = PRINT_CREATE_TABLE; }
    | dropTable() { q = PRINT_DROP_TABLE; }
    | descQuery() { q = PRINT_DESC; }
    | selectQuery() { q = PRINT_SELECT; }
    | insertQuery() { q = PRINT_INSERT; }
    | deleteQuery() { q = PRINT_DELETE; }
    | showTableQuery() { q = PRINT_SHOW_TABLES; }
  )
  (
    { return q; }
  )
}

// "show tables" Query
void showTableQuery() : {} {
  <SHOW> <TABLES>
  { dbms.showTables(); }
}

/// @brief  Parse "create table <table_name> (<table element list>)" form
void createTableQuery() :
{
  String tablename;
  Pair<ArrayList<Field>, ArrayList<Constraint>> fields;
}
{
  <CREATE> <TABLE>
  tablename = tableName()
  fields = tableElementList() {
    try {
      dbms.addTable(tablename, fields);
    } catch (QueryError qe) {
      System.out.println("Create table has failed: " + qe.getMessage());
      return;
    } catch (SchemaError se) {
      System.out.println(se.getMessage());
      return;
    }
    System.out.println("'" + tablename + "' table is created");
  }
}

/// @brief  Parse "( <table element list> )" format
Pair<ArrayList<Field>, ArrayList<Constraint>> tableElementList() : {
  Pair<Field, Constraint> field;
  ArrayList<Field> fields = new ArrayList<Field>();
  ArrayList<Constraint> constraints = new ArrayList<Constraint>();
} {
  <LEFT_PAREN> field = tableElement() {
    if (field.first() != null) fields.add(field.first());
    else constraints.add(field.second());
  }
  ( <COMMA> field = tableElement() {
    if (field.first() != null) fields.add(field.first());
    else constraints.add(field.second());
  })* <RIGHT_PAREN>
  { return new Pair<ArrayList<Field>, ArrayList<Constraint>>(fields, constraints); }
}

/// @brief  Parse <table element> format
Pair<Field, Constraint> tableElement() : {
  Field field;
  Constraint constraint;
} {
  field = columnDefinition() { return new Pair<Field, Constraint>(field, null); }
| constraint = tableConstraintDefinition() { return new Pair<Field, Constraint>(null, constraint); }
}

/// @brief  Parse "<column_name> <data type> [not null]" format
Field columnDefinition() :
{
  String column;
  DataType type;
  boolean not_null = false;
} {
  column = columnName()
  type = dataType() ( notNull() { not_null = true; })?
  { return new Field(column, type, not_null); }
}

/// @brief  Parse "[not] null" format
void notNull() : {} {
  <NOT> <NULL>
}

/// @brief  Parse primary key or foreign key constraint formats
Constraint tableConstraintDefinition() : {
  Constraint constraint;
} {
  constraint = primaryKeyConstraint()
  { return constraint; }
| constraint = referentialConstraint()
  { return constraint; }
}

/// @brief  Parse "primary key(...)" format
Constraint primaryKeyConstraint() : {
  ArrayList<String> columns;
} {
  <PRIMARY> <KEY> columns = columnNameList()
  { return new PkConstraint(columns); }
}

/// @brief  Parse "foreign key(...)" format
FkConstraint referentialConstraint() : {
  ArrayList<String> columns;
  String table;
  ArrayList<String> referenceList;
} {
  <FOREIGN> <KEY> columns = columnNameList() <REFERENCES>
  table = tableName()
  referenceList = columnNameList()
  { return new FkConstraint(columns, table, referenceList); }
}

/// @brief  Parse "(<columnName>, ...)" format
ArrayList<String> columnNameList() : {
  ArrayList<String> result = new ArrayList<String>();
  String column;
} {
  <LEFT_PAREN> column = columnName() { result.add(column.toString().toLowerCase()); }
  ( <COMMA> column = columnName() { result.add(column.toString().toLowerCase()); } )* <RIGHT_PAREN>
  { return result; }
}

/// @brief  Parse integer / char(size) / date value format
DataType dataType() : { Token length; } {
  <INT> { return new IntType(); }
| ( <CHAR> <LEFT_PAREN> length = <INT_VALUE> <RIGHT_PAREN> ) { return new CharType(Integer.parseInt(length.image)); }
| <DATE> { return new DateType(); }
}

/// @brief  Parse table name
String tableName() : { Token tablename; } {
  tablename = <LEGAL_IDENTIFIER>
  { return tablename.toString().toLowerCase(); }
}

/// @brief  Parse column name
String columnName() : { Token column; } {
  column = <LEGAL_IDENTIFIER>
  { return column.toString().toLowerCase(); }
}

/// @brief  Parse "drop table <tableName>" format
void dropTable() : {
  String tablename;
} {
  <DROP> <TABLE> tablename = tableName()
  {
    try {
      dbms.dropTable(tablename);
    } catch ( QueryError qe ) {
      System.out.println("Drop table has failed: " + qe.getMessage());
      return;
    }
    System.out.println("'" + tablename + "' is dropped");
  }
}

/// @brief  Parse "desc <tableName>" format
void descQuery() : {
  String tablename;
} {
  <DESC> tablename = tableName()
  {
    try {
    dbms.descTable(tablename);
    } catch ( QueryError qe ) {
      System.out.println(qe.getMessage());
    }
  }
}

/// @brief  Parse "select ..." format
void selectQuery() : {} {
  <SELECT> selectList() tableExp()
}

/// @brief Parse select list
/// '*' or list of selected columns
void selectList() : {} {
  <ASTERISK> | selectedColumn() ( <COMMA> selectedColumn() )*
}

/// @brief Parse selected column
/// tableName and columnName share same token <LEGAL_IDENTIFIER>, so looking 2 tokens ahead is required to
/// determine first token will be used as tableName (if 2nd token is ".") or columnName
void selectedColumn() : {} {
  (LOOKAHEAD(2) tableName() <PERIOD> columnName() | columnName() ) ( <AS> columnName() ) ?
}

/// @brief Parse "from ... [where ...]" format
void tableExp() : {} {
  fromClause() ( whereClause() ) ?
}

/// @brief Parse from clause
void fromClause() : {} {
  <FROM> tableReferenceList()
}

/// @brief Parse table reference list
void tableReferenceList() : {} {
  referedTable() (<COMMA> referedTable()) *
}

/// @brief Parse "<tableName> [as <tableName>]" format
void referedTable() : {} {
  tableName() (<AS> tableName()) ?
}

/// @brief Parse "where <predicate>" format
void whereClause() : {} {
  <WHERE> booleanValueExp()
}

/// Collecting order of "or" "and" "not" affects operator precedence
/// "not" should be collected first, then "and" and finally "or"

/// @brief Collect "or" connected terms
void booleanValueExp() : {} {
  booleanTerm() ( <OR> booleanValueExp() ) ?
}

/// @brief Collect "and" connected terms
void booleanTerm() : {} {
  booleanFactor() ( <AND> booleanTerm() ) ?
}

/// @brief Collect "not" connected terms
void booleanFactor() : {} {
  (<NOT>) ? booleanTest()
}

/// @brief  Parse expression which returns boolean value
void booleanTest() : {} {
  predicate() | parenthesizedBooleanExp()
}

/// @brief  Parse "( <boolean expression> )" format
void parenthesizedBooleanExp() : {} {
  <LEFT_PAREN> booleanValueExp() <RIGHT_PAREN>
}

/// @brief  Parse predicate statement
/// Lookahead of 4 tokens is required because longest command prefix for comparison predicate and null predicate
/// is <tableName> "." <columnName>. (4th token will be "is" or comparison operator, then we can determine)
void predicate() : {} {
  LOOKAHEAD(4) comparisonPredicate() | nullPredicate()
}

/// @brief  Parse comparison predicate
void comparisonPredicate() : {} {
  compOperand() compOp() compOperand()
}

/// @brief Parse comparison operand
/// tableName and columnName share same token <LEGAL_IDENTIFIER>, so looking 2 tokens ahead is required to
/// determine first token will be used as tableName (if 2nd token is ".") or columnName
void compOperand() : {} {
  comparableValue()
| (LOOKAHEAD(2) tableName() <PERIOD> columnName() | columnName() )
}

/// @brief Parse comparison operators
void compOp() : {} {
  <LEQ> | <GEQ> | <LT> | <GT> | <EQ> | <NEQ>
}

/// @brief Parse comparable values
void comparableValue() : {} {
  <INT_VALUE> | <CHARSTRING> | <DATE_VALUE>
}

/// @brief Parse null predicate
/// tableName and columnName share same token <LEGAL_IDENTIFIER>, so looking 2 tokens ahead is required to
/// determine first token will be used as tableName (if 2nd token is ".") or columnName
void nullPredicate() : {} {
  (LOOKAHEAD(2) tableName() <PERIOD> columnName() | columnName() ) nullOperation()
}

/// @brief Parse null operation
void nullOperation() : {} {
  <IS> (<NOT>) ? <NULL>
}

/// @brief Parse "delete from <tableName> [where ...]" format
void deleteQuery() : {} {
  <DELETE> <FROM> tableName() ( whereClause() ) ?
}

/// @brief Parse "insert into ..." format
void insertQuery() : {} {
  <INSERT> <INTO> tableName() ( columnNameList() ) ?
  <VALUES> <LEFT_PAREN> value() (<COMMA> value())* <RIGHT_PAREN>
}

/// @brief Parse null or comparable value
void value() : {} {
  <NULL> | comparableValue()
}
/**
 * @file    SimpleDBMSGramar.jj
 * @author  2014-18992 신동진
 * @brief   Basic SQL grammar parser
 */
options {
  static = true;
  DEBUG_PARSER = false;
  IGNORE_CASE = true;
}

PARSER_BEGIN(SimpleDBMSParser)

public class SimpleDBMSParser {
  /// Type of SQL queries
  public static final int PRINT_SYNTAX_ERROR = 0;
  public static final int PRINT_CREATE_TABLE = 1;
  public static final int PRINT_DROP_TABLE =   2;
  public static final int PRINT_DESC =         3;
  public static final int PRINT_SELECT =       4;
  public static final int PRINT_INSERT =       5;
  public static final int PRINT_DELETE =       6;
  public static final int PRINT_SHOW_TABLES =  7;

  public static void main(String args[]) throws ParseException {
    SimpleDBMSParser parser = new SimpleDBMSParser(System.in);
    System.out.print("DB_2014-18992> ");

    while (true) {
      try {
        parser.command();
      }
      catch (Exception e) {
        printMessage(PRINT_SYNTAX_ERROR);
        SimpleDBMSParser.ReInit(System.in);
      }
    }
  }

  public static void printMessage(int q) {
    switch(q) {
      case PRINT_SYNTAX_ERROR:
      	System.out.println("Syntax error");
      	break;
      case PRINT_CREATE_TABLE:
      	System.out.println("\'CREATE TABLE\' requested");
      	break;
      case PRINT_DROP_TABLE:
      	System.out.println("\'DROP TABLE\' requested");
      	break;
      case PRINT_DESC:
      	System.out.println("\'DESC' requested");
      	break;
      case PRINT_INSERT:
      	System.out.println("\'INSERT' requested");
      	break;
      case PRINT_DELETE:
      	System.out.println("\'DELETE' requested");
      	break;
      case PRINT_SELECT:
      	System.out.println("\'SELECT' requested");
      	break;
      case PRINT_SHOW_TABLES:
      	System.out.println("\'SHOW TABLES' requested");
      	break;
    }
    System.out.print("DB_2014-18992> ");
  }
}

PARSER_END(SimpleDBMSParser)

SKIP : { " " | "\r" | "\t" | "\n" }

TOKEN : /* Keywords */ {
  < EXIT : "exit" >
| < INT : "int" >
| < CHAR : "char" >
| < DATE : "date" >
| < REFERENCES : "references" >
| < DESC : "desc" >
| < SELECT : "select" >
| < AS : "as" >
| < FROM : "from" >
| < WHERE : "where" >
| < OR : "or" >
| < AND : "and" >
| < NOT : "not" >
| < IS : "is" >
| < VALUES : "values" >
| < NULL : "null" >
| < TABLES : "tables">
| < TABLE : "table">
| < KEY : "key" >
| < INSERT : "insert" >
| < INTO : "into" >
| < DELETE : "delete" >
| < DROP : "drop">
| < SHOW : "show">
| < PRIMARY : "primary">
| < CREATE : "create">
| < FOREIGN : "foreign">
}

/// Tokens that are not reserved keywords
TOKEN : {
  < SEMICOLON : ";" >
| < LEFT_PAREN : "(" >
| < RIGHT_PAREN : ")" >
| < COMMA : "," >
| < #UNDERSCORE : "_" >
| < SIGN : "+" | "-" >
| < DATE_VALUE : <NNNN> "-" <NN> "-" <NN> >
| < DIGIT : [ "0"-"9" ] >
| < #ALPHABET : [ "A"-"Z", "a"-"z" ] >
| < #QUOTE : "'">
| < PERIOD : ".">
| < ASTERISK : "*">
| < #NNNN : (<DIGIT>){4} >
| < #NN : (<DIGIT>){2} >
| < LEQ : "<=">
| < LT : "<">
| < GEQ : ">=">
| < GT : ">">
| < EQ : "=">
| < NEQ : "!=">
| < CHARSTRING : <QUOTE> (~["\'"])* <QUOTE> >
| < LEGAL_IDENTIFIER : <ALPHABET> ( <ALPHABET> | <UNDERSCORE> )* >
}

void command() : {} {
  queryList()
| ( <EXIT> <SEMICOLON> { System.exit(0); } )
}

void queryList() : { int q; } {
  (
    q = query()
    <SEMICOLON>
    { printMessage(q); }
  )+
}

/// @brief  Parse query and return its type
/// @param  int q Result query code
int query() : { int q; } {
  (
    createTableQuery() { q = PRINT_CREATE_TABLE; }
    | dropTable() { q = PRINT_DROP_TABLE; }
    | descQuery() { q = PRINT_DESC; }
    | selectQuery() { q = PRINT_SELECT; }
    | insertQuery() { q = PRINT_INSERT; }
    | deleteQuery() { q = PRINT_DELETE; }
    // "show tables" Query
    | <SHOW> <TABLES> { q = PRINT_SHOW_TABLES; }
  )
  (
    { return q; }
  )
}

/// @brief  Parse "create table <table_name> (<table element list>)" form
void createTableQuery() : {} {
  <CREATE> <TABLE> tableName() tableElementList()
}

/// @brief  Parse "( <table element list> )" format
void tableElementList() : {} {
  <LEFT_PAREN> tableElement() ( <COMMA> tableElement() )* <RIGHT_PAREN>
}

/// @brief  Parse <table element> format
void tableElement() : {} {
  columnDefinition()
| tableConstraintDefinition()
}

/// @brief  Parse "<column_name> <data type> [not null]" format
void columnDefinition() : {} {
  columnName() dataType() ( notNull() )?
}

/// @brief  Parse "[not] null" format
void notNull() : {} {
  <NOT> <NULL>
}

/// @brief  Parse primary key or foreign key constraint formats
void tableConstraintDefinition() : {} {
  primaryKeyConstraint()
| referentialConstraint()
}

/// @brief  Parse "primary key(...)" format
void primaryKeyConstraint() : {} {
  <PRIMARY> <KEY> columnNameList()
}

/// @brief  Parse "foreign key(...)" format
void referentialConstraint() : {} {
  <FOREIGN> <KEY> columnNameList() <REFERENCES> tableName() columnNameList()
}

/// @brief  Parse "(<columnName>, ...)" format
void columnNameList() : {} {
  <LEFT_PAREN> columnName() ( <COMMA> columnName() )* <RIGHT_PAREN>
}

/// @brief  Parse integer / char(size) / date value format
void dataType() : {} {
  <INT>
| ( <CHAR> <LEFT_PAREN> intValue() <RIGHT_PAREN> )
| <DATE>
}

/// @brief  Parse table name
void tableName() : {} {
  <LEGAL_IDENTIFIER>
}

/// @brief  Parse column name
void columnName() : {} {
  <LEGAL_IDENTIFIER>
}

/// @brief  Parse integer value
void intValue() : {} {
  ( <SIGN> )? ( <DIGIT> )+
}

/// @brief  Parse "drop table <tableName>" format
void dropTable() : {} {
  <DROP> <TABLE> tableName()
}

/// @brief  Parse "desc <tableName>" format
void descQuery() : {} {
  <DESC> tableName()
}

/// @brief  Parse "select ..." format
void selectQuery() : {} {
  <SELECT> selectList() tableExp()
}

/// @brief Parse select list
/// '*' or list of selected columns
void selectList() : {} {
  <ASTERISK> | selectedColumn() ( <COMMA> selectedColumn() )*
}

/// @brief Parse selected column
/// tableName and columnName share same token <LEGAL_IDENTIFIER>, so looking 2 tokens ahead is required to
/// determine first token will be used as tableName (if 2nd token is ".") or columnName
void selectedColumn() : {} {
  (LOOKAHEAD(2) tableName() <PERIOD> columnName() | columnName() ) ( <AS> columnName() ) ?
}

/// @brief Parse "from ... [where ...]" format
void tableExp() : {} {
  fromClause() ( whereClause() ) ?
}

/// @brief Parse from clause
void fromClause() : {} {
  <FROM> tableReferenceList()
}

/// @brief Parse table reference list
void tableReferenceList() : {} {
  referedTable() (<COMMA> referedTable()) *
}

/// @brief Parse "<tableName> [as <tableName>]" format
void referedTable() : {} {
  tableName() (<AS> tableName()) ?
}

/// @brief Parse "where <predicate>" format
void whereClause() : {} {
  <WHERE> booleanValueExp()
}

/// Collecting order of "or" "and" "not" affects operator precedence
/// "not" should be collected first, then "and" and finally "or"

/// @brief Collect "or" connected terms
void booleanValueExp() : {} {
  booleanTerm() ( <OR> booleanValueExp() ) ?
}

/// @brief Collect "and" connected terms
void booleanTerm() : {} {
  booleanFactor() ( <AND> booleanTerm() ) ?
}

/// @brief Collect "not" connected terms
void booleanFactor() : {} {
  (<NOT>) ? booleanTest()
}

/// @brief  Parse expression which returns boolean value
void booleanTest() : {} {
  predicate() | parenthesizedBooleanExp()
}

/// @brief  Parse "( <boolean expression> )" format
void parenthesizedBooleanExp() : {} {
  <LEFT_PAREN> booleanValueExp() <RIGHT_PAREN>
}

/// @brief  Parse predicate statement
/// Lookahead of 4 tokens is required because longest command prefix for comparison predicate and null predicate
/// is <tableName> "." <columnName>. (4th token will be "is" or comparison operator, then we can determine)
void predicate() : {} {
  LOOKAHEAD(4) comparisonPredicate() | nullPredicate()
}

/// @brief  Parse comparison predicate
void comparisonPredicate() : {} {
  compOperand() compOp() compOperand()
}

/// @brief Parse comparison operand
/// tableName and columnName share same token <LEGAL_IDENTIFIER>, so looking 2 tokens ahead is required to
/// determine first token will be used as tableName (if 2nd token is ".") or columnName
void compOperand() : {} {
  comparableValue()
| (LOOKAHEAD(2) tableName() <PERIOD> columnName() | columnName() )
}

/// @brief Parse comparison operators
void compOp() : {} {
  <LEQ> | <GEQ> | <LT> | <GT> | <EQ> | <NEQ>
}

/// @brief Parse comparable values
void comparableValue() : {} {
  intValue() | <CHARSTRING> | <DATE_VALUE>
}

/// @brief Parse null predicate
/// tableName and columnName share same token <LEGAL_IDENTIFIER>, so looking 2 tokens ahead is required to
/// determine first token will be used as tableName (if 2nd token is ".") or columnName
void nullPredicate() : {} {
  (LOOKAHEAD(2) tableName() <PERIOD> columnName() | columnName() ) nullOperation()
}

/// @brief Parse null operation
void nullOperation() : {} {
  <IS> (<NOT>) ? <NULL>
}

/// @brief Parse "delete from <tableName> [where ...]" format
void deleteQuery() : {} {
  <DELETE> <FROM> tableName() ( whereClause() ) ?
}

/// @brief Parse "insert into ..." format
void insertQuery() : {} {
  <INSERT> <INTO> tableName() ( columnNameList() ) ?
  <VALUES> <LEFT_PAREN> value() (<COMMA> value())* <RIGHT_PAREN>
}

/// @brief Parse null or comparable value
void value() : {} {
  <NULL> | comparableValue()
}